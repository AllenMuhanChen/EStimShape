package org.xper.allen.eye.headfree;

import org.xper.Dependency;
import org.xper.drawing.Coordinates2D;
import org.xper.eye.zero.MovingAverageEyeZeroAlgorithm;

/**
 * Two states:
 * State 1: Animal fixates out of inner range (usually previous fixation). Then we calculate the new eye zero
 * using all of the eye data we have. (Should set a wide algorithm_eye_window_threshold)
 * State 2: Animal fixates inside of the inner range. Then we can calculate the new zero
 * using only data from the inner range. 
 * 
 * This allows for calculating new eye zeros quickly when animal's eye zero shifts due to headmovement
 * but this doesn't come at the price of reduced accuracy of calculations compared to when we just set the threshold larger.
 * 
 * The intended behavior of this algorithm is when a monkey fixates but head is
 * in a slightly different location, the recorded
 * eye zero can be a few degrees away from in the previous trial. We can then use
 * the new average fixation location as the eye zero. But when the eye zero 
 * does not shift, we calculate new eye zero values only using data from when
 * the eye is in the inner range for more accuracy. 
 * @author r2_allen
 *
 */
public class HeadFreeEyeZeroAlgorithm extends MovingAverageEyeZeroAlgorithm{
	@Dependency
	private double eyeZeroInnerThreshold;
	@Dependency
	private double eyeZeroInnerUpdateMinSample;

	private boolean collectingInnerEyeZeroSignal;

	private boolean inInnerState;

	private int innerSpan;
	private Coordinates2D[] eyeInnerZero;
	private int eyeZeroInnerIndex=0;

	private Coordinates2D eyeZeroInnerSum = new Coordinates2D();
	private int eyeZeroInnerCount;




	public HeadFreeEyeZeroAlgorithm(int span, int innerSpan) {
		super(span);
		this.innerSpan = innerSpan;
		setEyeInnerZero(new Coordinates2D[innerSpan]);
		// TODO Autogenerated constructor stub
		for (int i = 0; i < innerSpan; i++) {
			getEyeInnerZero()[i] = new Coordinates2D();
		}
	}

	public Coordinates2D getNewEyeZero() {
		if (getEyeZeroIndex() == 0)
			return null;

		if(inInnerState) {
			if(getEyeZeroInnerIndex()==0) {
				return null;
			}
			Coordinates2D average = new Coordinates2D();
			int n = getEyeZeroInnerIndex() > getEyeInnerZero().length ? getEyeInnerZero().length : getEyeZeroInnerIndex();
			System.out.println("AC908450345843: Inner n: " + n);
			if(n>0)
			for (int i = 0; i < n; i++) {
				average.setX(average.getX() + getEyeInnerZero()[i].getX());
				average.setY(average.getY() + getEyeInnerZero()[i].getY());
			}

			average.setX(average.getX() / n);
			average.setY(average.getY() / n);
			System.out.println("AC000000: INNER Average: " + average);
			return average;
		}
		else {
			Coordinates2D average = new Coordinates2D();
			int n = getEyeZeroIndex() > getEyeZero().length ? getEyeZero().length : getEyeZeroIndex();

			for (int i = 0; i < n; i++) {
				average.setX(average.getX() + getEyeZero()[i].getX());
				average.setY(average.getY() + getEyeZero()[i].getY());
			}

			average.setX(average.getX() / n);
			average.setY(average.getY() / n);
			System.out.println("AC000000: TOTAL Average: " + average);

			//Reset Inner Data
			setEyeInnerZero(new Coordinates2D[innerSpan]);
			// TODO Autogenerated constructor stub
			for (int i = 0; i < innerSpan; i++) {
				getEyeInnerZero()[i] = new Coordinates2D();
			}
			eyeZeroInnerIndex=0;
			System.out.println("AC222222: Resetting InnerEyeZero");
			return average;

		}

	}

	public void startEyeZeroSignalCollection() {
		inInnerState = false;
		setEyeZeroSampleCount(0);
		getEyeZeroSampleSum().setX(0);
		getEyeZeroSampleSum().setY(0);


		setCollectingEyeZeroSignal(true);
	}

	public void startInnerEyeZeroSignalCollection() {
		inInnerState = true;
		setEyeZeroInnerCount(0);
		getEyeZeroInnerSum().setX(0);
		getEyeZeroInnerSum().setY(0);

		setCollectingInnerEyeZeroSignal(true);
	}

	public void collectEyeZeroSignal(Coordinates2D voltage) {
		if (isCollectingEyeZeroSignal()) {
			setEyeZeroSampleCount(getEyeZeroSampleCount() + 1);
			getEyeZeroSampleSum().setX(getEyeZeroSampleSum().getX() + voltage.getX());
			getEyeZeroSampleSum().setY(getEyeZeroSampleSum().getY() + voltage.getY());
		}
	}

	public void collectEyeZeroInnerSignal(Coordinates2D voltage) {
		if (isCollectingInnerEyeZeroSignal()) {
			setEyeZeroInnerCount(getEyeZeroInnerCount() + 1);
			getEyeZeroInnerSum().setX(getEyeZeroInnerSum().getX() + voltage.getX());
			getEyeZeroInnerSum().setY(getEyeZeroInnerSum().getY() + voltage.getY());
		}
	}

	public void stopEyeZeroSignalCollection() {
		setCollectingEyeZeroSignal(false);
		setCollectingInnerEyeZeroSignal(false);

		//If we have enough inner trials, we'll use this, but if not we take the entire average. 
		if (getEyeZeroInnerCount() >= getEyeZeroInnerUpdateMinSample()) {
			int i = getEyeZeroInnerIndex() % getEyeInnerZero().length;
			getEyeInnerZero()[i].setX(getEyeZeroInnerSum().getX() / getEyeZeroInnerCount());
			getEyeInnerZero()[i].setY(getEyeZeroInnerSum().getY() / getEyeZeroInnerCount());
			setEyeZeroInnerIndex(getEyeZeroInnerIndex() + 1);
		}
		if (getEyeZeroSampleCount() >= getEyeZeroUpdateMinSample()) { 
			int i = getEyeZeroIndex() % getEyeZero().length;
			getEyeZero()[i].setX(getEyeZeroSampleSum().getX() / getEyeZeroSampleCount());
			getEyeZero()[i].setY(getEyeZeroSampleSum().getY() / getEyeZeroSampleCount());
			setEyeZeroIndex(getEyeZeroIndex() + 1);
		}
	}


	public double getEyeZeroInnerThreshold() {
		return eyeZeroInnerThreshold;
	}

	public void setEyeZeroInnerThreshold(double eyeZeroInnerThreshold) {
		this.eyeZeroInnerThreshold = eyeZeroInnerThreshold;
	}

	public Coordinates2D getEyeZeroInnerSum() {
		return eyeZeroInnerSum;
	}

	public void setEyeZeroInnerSum(Coordinates2D eyeZeroInnerSum) {
		this.eyeZeroInnerSum = eyeZeroInnerSum;
	}

	protected int getEyeZeroInnerCount() {
		return eyeZeroInnerCount;
	}

	protected void setEyeZeroInnerCount(int eyeZeroInnerCount) {
		this.eyeZeroInnerCount = eyeZeroInnerCount;
	}

	public boolean isCollectingInnerEyeZeroSignal() {
		return collectingInnerEyeZeroSignal;
	}

	public void setCollectingInnerEyeZeroSignal(boolean collectingInnerEyeZeroSignal) {
		this.collectingInnerEyeZeroSignal = collectingInnerEyeZeroSignal;
	}

	public Coordinates2D[] getEyeInnerZero() {
		return eyeInnerZero;
	}

	public void setEyeInnerZero(Coordinates2D[] eyeInnerZero) {
		this.eyeInnerZero = eyeInnerZero;
	}

	public double getEyeZeroInnerUpdateMinSample() {
		return eyeZeroInnerUpdateMinSample;
	}

	public void setEyeZeroInnerUpdateMinSample(double eyeZeroInnerUpdateMinSample) {
		this.eyeZeroInnerUpdateMinSample = eyeZeroInnerUpdateMinSample;
	}

	private int getEyeZeroInnerIndex() {
		return eyeZeroInnerIndex;
	}

	private void setEyeZeroInnerIndex(int eyeZeroInnerIndex) {
		this.eyeZeroInnerIndex = eyeZeroInnerIndex;
	}



}

