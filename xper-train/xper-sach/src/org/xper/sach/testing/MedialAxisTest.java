//package org.xper.sach.testing;
//
//import java.awt.*;
//import java.applet.Applet;
////import java.lang.String;
////import java.lang.Math;
//
//public class MedialAxisTest extends Applet implements Runnable {
//	/**
//	 * 
//	 */
//	private static final long serialVersionUID = 1L;
//	
//	private final double BIG_NUMBER = 9999.0,SMALL_NUMBER = 0.000001;
//	private final int screenWidth = 600,screenHeight=400;
//	private Thread thread;
//	private Image    image;
//	private Graphics graphics;
//
//	private PointList list = null, CurrentPoint = null;
//	private final String[] Backgrounds = {"Gray", "Black", "White"};
//	private Color BgCol;
//
//	private final int Grid = 9;
//	private final int STATE_START = 0, STATE_CHANGE = 1, STATE_COMPUTE = 2, STATE_DO = 3;
//	private final String[] StateStrings = 
//		{"Drawing a New Shape","Changing Shape","Coputing Medial Axis"};
//	private int State = STATE_START;
//	private Label StateLabel = new Label(StateStrings[0]);
//	private Button ComputeButton = new Button("Medial Axis");
//
//	private Polygon Poly = null;// this is the polygon generated by the user
//	private int[] A,B,C;		// these are the arrays of A B and C respectively
//	// in the equation AX+BY+C=0 that we make from each
//	// calculated polygon edge.
//	private double[] M;			// the SHIPUA of the line
//	private int MinX = -1, MinY = -1, MaxX = -1, MaxY = -1, CurrX = -1, CurrY = -1;
//	private int LastWasPoint;
//
//	//---------------------------------------------------------------------------------
//	// Here we'll creat the panel, buttons and list box, and resize the screen
//	public void init()
//	{
//		Button RestartButton = new Button("Restart");
//		Panel TopPanel = new Panel();
//		TopPanel.add(StateLabel);
//		TopPanel.add(RestartButton);
//		TopPanel.add(ComputeButton);
//		ComputeButton.enable(false);
//		Choice c1;
//		TopPanel.add(c1 = new Choice());
//		for (int i = 0; i < Backgrounds.length; i++)
//			c1.addItem(Backgrounds[i]);
//		add("South", TopPanel);
//		resize(screenWidth,screenHeight);
//		image    = createImage(screenWidth, screenHeight);
//		graphics = image.getGraphics();
//		BgCol    = Color.lightGray;//getBackground();
//		validate();
//	}
//	//---------------------------------------------------------------------------------
//	public void start()
//	{
//		//Start animating!
//		if (thread == null)
//			thread = new Thread(this);
//		thread.start();
//	}
//	//---------------------------------------------------------------------------------
//	public void stop()
//	{
//		//Stop the animating thread.
//		thread = null;
//	}
//	//---------------------------------------------------------------------------------
//	// Handle events such as the list box and the buttons
//	public boolean action(Event evt, Object arg)
//	{
//		if (evt.target instanceof Choice)
//		{
//			//User has chosen a background...
//			for (int i = 0; i < Backgrounds.length; i++)
//				if (Backgrounds[i].equals(arg))
//				{
//					switch (i)
//					{
//					case 0: BgCol=Color.lightGray; break;
//					case 1: BgCol=Color.black; break;
//					case 2: BgCol=Color.white; break;
//					}
//					StateLabel.setBackground(BgCol);
//					if (BgCol == Color.black)
//						StateLabel.setForeground(Color.white);
//					else
//						StateLabel.setForeground(Color.black);
//					break;
//				}
//		}
//		// User has pressed a button (probably)
//		else if ("Restart".equals(arg))
//		{
//			list = null;
//			Poly = null;
//			State = STATE_START;
//			StateLabel.setText(StateStrings[State]);
//			ComputeButton.enable(false);
//		}
//		else if ("Medial Axis".equals(arg))
//		{
//			showStatus("Medial Axis is being computed...");
//			State = STATE_COMPUTE;
//			StateLabel.setText(StateStrings[State]);
//		}
//		else
//			return super.action(evt,arg);
//		repaint();
//		return true;
//	}
//	//---------------------------------------------------------------------------------
//	public void run()
//	{
//		//Thread.currentThread().setPriority(Thread.MIN_PRIORITY);
//		long startTime = System.currentTimeMillis();
//
//		while (Thread.currentThread() == thread) {
//			if (State == STATE_COMPUTE)
//			{
//				if (Poly == null)
//				{	// first time in this State - compute A,B,C and M
//					Poly = list.GetPolygon();
//					A = new int[Poly.npoints];
//					B = new int[Poly.npoints];
//					C = new int[Poly.npoints];
//					M = new double[Poly.npoints];
//					for (int i = 1; i < Poly.npoints; i++)
//					{
//						A[i-1] = Poly.ypoints[i-1]-Poly.ypoints[i];
//						B[i-1] = Poly.xpoints[i]-Poly.xpoints[i-1];
//						C[i-1] = Poly.ypoints[i]*Poly.xpoints[i-1] -
//								Poly.xpoints[i]*Poly.ypoints[i-1];
//						M[i-1] = (0.0+Poly.ypoints[i]-Poly.ypoints[i-1])/
//								(0.0+Poly.xpoints[i]-Poly.xpoints[i-1]+SMALL_NUMBER);
//					}
//					A[Poly.npoints-1] = Poly.ypoints[Poly.npoints-1]-Poly.ypoints[0];
//					B[Poly.npoints-1] = Poly.xpoints[0]-Poly.xpoints[Poly.npoints-1];
//					C[Poly.npoints-1] = Poly.ypoints[0]*Poly.xpoints[Poly.npoints-1] -
//							Poly.xpoints[0]*Poly.ypoints[Poly.npoints-1];
//					M[Poly.npoints-1] = (0.0+Poly.ypoints[0]-Poly.ypoints[Poly.npoints-1])/
//							(0.0+Poly.xpoints[0]-Poly.xpoints[Poly.npoints-1]+SMALL_NUMBER);
//
//					Rectangle Rect = Poly.getBounds();
//					CurrX = MinX = Rect.x;
//					CurrY = MinY = Rect.y;
//					MaxX = Rect.x+Rect.width;
//					MaxY = Rect.y+Rect.height;
//					State = STATE_DO;
//					repaint();
//				}
//
//				//repaint();	// I don't want to repaint all the time since I do my
//				// calculations in the Update method
//			}
//
//			//Delay depending on how far we are behind.
//			try {
//				startTime += 100;
//				Thread.sleep(Math.max(0,startTime-System.currentTimeMillis()));
//			} catch (InterruptedException e) {
//				break;
//			}
//		}
//	}
//	//---------------------------------------------------------------------------------
//	// Handle Mouse events
//	public boolean handleEvent(Event e)
//	{
//		if (e.id == e.MOUSE_DOWN)
//		{
//			if (State == STATE_START)
//			{
//				if (e.modifiers == e.META_MASK)
//				{
//					// Right mouse click is interpreted as closing the shape (if possible)
//					if (list != null && list.Next != null)
//					{
//						// Check that is we add the first point we still have a simple shape
//						/* Not implemented yet */
//						State = STATE_CHANGE;
//						StateLabel.setText(StateStrings[State]);
//						ComputeButton.enable(true);
//						showStatus("Shape closed. You can now drag the vertexes around or compute Medial Axis.");
//					}
//				}
//				else
//				{
//					if (list == null)
//					{
//						list = new PointList(Grid*((e.x+Grid/2)/Grid),Grid*((e.y+Grid/2)/Grid));
//						showStatus("Shape started.");
//					}
//					else
//					{
//						// If we closed a circle
//						if (list.X == Grid*((e.x+Grid/2)/Grid) && list.Y == Grid*((e.y+Grid/2)/Grid))
//						{
//							State = STATE_CHANGE;
//							StateLabel.setText(StateStrings[State]);
//							ComputeButton.enable(true);
//							showStatus("Shape closed. You can now drag the vertexes around or compute Medial Axis.");
//						}
//						// Check that we didn't choose a previous point
//						else if (list.FindPoint(Grid*((e.x+Grid/2)/Grid),Grid*((e.y+Grid/2)/Grid)) == null)
//						{
//							// Check that we still have a simple shape (No self cuts)
//							/* Not implemented yet */
//							list.AddLast(Grid*((e.x+Grid/2)/Grid),Grid*((e.y+Grid/2)/Grid));
//							showStatus("Point added.");
//						}
//						else
//							showStatus("Shape should not intersect. Point not added.");
//					}
//				}
//			}
//			else if (State == STATE_CHANGE)
//				CurrentPoint = list.FindPoint(Grid*((e.x+Grid/2)/Grid),Grid*((e.y+Grid/2)/Grid));
//			else
//				return super.handleEvent(e);
//		}
//		else if (e.id == e.MOUSE_DRAG && CurrentPoint != null)
//		{
//			CurrentPoint.X = Grid*((e.x+Grid/2)/Grid);
//			CurrentPoint.Y = Grid*((e.y+Grid/2)/Grid);
//			showStatus("Dragging a vertex");
//		}
//		else if (e.id == e.MOUSE_UP && CurrentPoint != null)
//		{
//			CurrentPoint.X = Grid*((e.x+Grid/2)/Grid);
//			CurrentPoint.Y = Grid*((e.y+Grid/2)/Grid);
//			CurrentPoint = null;
//			showStatus("Dropped a vertex. You can now drag a vertex or compute Medial Axis.");
//		}
//		else
//			return super.handleEvent(e);
//		repaint();
//		return true;
//	}
//	//---------------------------------------------------------------------------------
//	public void paint(Graphics g)
//	{
//		update(g);
//	}
//	//---------------------------------------------------------------------------------
//	public void update(Graphics graphics)//g)
//	{
//		setBackground(BgCol);
//		graphics.clearRect(0,0,screenWidth,screenHeight);
//
//		PointList tmp = list,last = null;
//		while (tmp != null)
//		{
//			graphics.setColor(Color.blue);
//			graphics.fill3DRect(tmp.X-Grid/2,tmp.Y-Grid/2,Grid,Grid,true);
//			if (last != null)
//			{
//				graphics.setColor(Color.cyan);
//				graphics.drawLine(last.X,last.Y,tmp.X,tmp.Y);
//			}
//			last = tmp;
//			tmp = tmp.Next;
//		}
//		if (list != null && State != STATE_START)
//		{
//			graphics.drawLine(last.X,last.Y,list.X,list.Y);
//			//graphics.fillPolygon(list.GetPolygon());
//		}
//
//		// this is the main calculation loop for this class
//		if (State == STATE_DO && Poly != null)
//		{
//			graphics.setColor(Color.red);
//
//			double MinDistance,Dist=-1,LastDist,FirstDist=-1;
//			int edge,times,LastWasPoint2,FirstWasPoint=-1;
//			for (int j = MinY; j < MaxY; j++)
//				for (int i = MinX; i < MaxX; i++)
//					if (Poly.contains(i,j))
//					{
//						//graphics.setColor(Color.green);
//						//graphics.drawOval(i,j,1,1);			
//						MinDistance = BIG_NUMBER;
//						times = -1;
//						LastWasPoint = -1;
//						for (edge = 0; edge < Poly.npoints; edge++)
//						{
//							LastWasPoint2 = LastWasPoint;
//							LastDist = Dist;
//
//							Dist = EdgeDistance(i,j,edge);
//
//							if (edge == 0)
//							{	// Save for the last edge checks
//								FirstDist = Dist;
//								FirstWasPoint = LastWasPoint;
//							}
//
//							if (Math.abs(Dist-LastDist)<1.2 && (
//									(LastWasPoint2 > -1 && LastWasPoint > -1) ||
//									(LastWasPoint == edge  && LastWasPoint2 == -1) ||
//									(LastWasPoint == -1 && LastWasPoint2 == edge) ))
//								Dist = BIG_NUMBER;
//							if (edge == Poly.npoints - 1)
//							{
//								if (Math.abs(Dist-FirstDist)<1.2 && (
//										(FirstWasPoint > -1 && LastWasPoint > -1) ||
//										(LastWasPoint == 0  && FirstWasPoint == -1) ||
//										(LastWasPoint == -1 && FirstWasPoint == 0) ))
//									Dist = BIG_NUMBER;
//							}
//
//							if (Math.abs(Dist-MinDistance) < 1.2)
//							{
//								times++;
//							}
//							else if (Dist < MinDistance)
//							{
//								times = 0;
//								MinDistance = Dist;
//							}
//						}
//
//						if (times > 0 && MinDistance != BIG_NUMBER)
//						{
//							//graphics.setColor(Color.red);
//							graphics.drawOval(i,j,1,1);
//							//if (times > 1)
//							//	graphics.drawOval(i-Grid/2,j-Grid/2,Grid,Grid);
//						}
//
//					}
//			// When done - return to STATE_CHANGE
//			State = STATE_CHANGE;
//			Poly = null;
//			StateLabel.setText(StateStrings[State]);
//			showStatus("Medial Axis computed. You can now drag the vertexes or recompute.");
//		}
//
//		//g.drawImage(image, 0, 0, this); 
//	}
//
//
//	//---------------------------------------------------------------------------------
//	// These are medial's private functions, dealing only with calculating distances
//	//---------------------------------------------------------------------------------
//	// The distance between the point (x,y) to the edge
//	private double Distance(int x,int y,int edge)
//	{
//		return Math.abs( (0.0+A[edge]*x+B[edge]*y+C[edge])/
//				(0.0+Math.sqrt(0.0+A[edge]*A[edge]+B[edge]*B[edge])) );
//	}
//	//---------------------------------------------------------------------------------
//	// The distance between the point (x,y) to the first point in the edge
//	private double PointDistance(int x,int y,int edge)
//	{
//		return Math.abs( Math.sqrt(0.0+(Poly.xpoints[edge]-x)*(Poly.xpoints[edge]-x)+
//				(Poly.ypoints[edge]-y)*(Poly.ypoints[edge]-y)) );
//	}
//	//---------------------------------------------------------------------------------
//	// The distance between the point (x,y) to the segment of the edge
//	// this means that if the point is not "above" the segment the distance
//	// is actually the distance to one of the ends of the segment
//	private double EdgeDistance(int x,int y,int edge)
//	{
//		int nextEdge;
//		if (edge < Poly.npoints - 1)
//			nextEdge = edge + 1;
//		else
//			nextEdge = 0;
//
//		// Check if the point (x,y) is "above" the segment (if it creates a
//		// triangle with no angles of more than 90 degrees)
//		// I'll do this by checking if the X point of the intersection between
//		// the edge and the ANACH that starts at (x,y) is between the edge's Xs
//
//		double interX;
//		if (Math.abs(M[edge]) <= 0.1)
//			interX = x;
//		else
//			interX = ((1.0*y + 1.0*x/M[edge]) - (1.0*Poly.ypoints[edge] - M[edge]*Poly.xpoints[edge]))/
//			(M[edge] + 1.0/M[edge]);
//
//		if ( (interX >= Poly.xpoints[edge] && interX <= Poly.xpoints[nextEdge]) ||
//				(interX <= Poly.xpoints[edge] && interX >= Poly.xpoints[nextEdge]) )
//		{
//			LastWasPoint = -1;
//			return Distance(x,y,edge);
//		}
//
//		// Now also checkthe Y (but only if M, the SHIPUA, is BIG so that we might had
//		// a problem)
//		if (Math.abs(M[edge]) >= BIG_NUMBER)
//			if ( (y >= Poly.ypoints[edge] && y <= Poly.ypoints[nextEdge]) ||
//					(y <= Poly.ypoints[edge] && y >= Poly.ypoints[nextEdge]) )
//			{
//				LastWasPoint = -1;
//				return Distance(x,y,edge);
//			}
//
//		// since it isn't between we return the distance to the edges
//		double far1,far2;
//		far1 = PointDistance(x,y,edge);
//		far2 = PointDistance(x,y,nextEdge);
//		if (far1 < far2)
//		{
//			LastWasPoint = edge;
//			return far1;
//		}
//		LastWasPoint = nextEdge;
//		return far2;
//	}
//	//---------------------------------------------------------------------------------
//}